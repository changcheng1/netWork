<!--
 * @Author: changcheng
 * @LastEditTime: 2023-03-21 13:59:13
-->
## OSI七层模型 理想化的模型 ，给网络划分层次

我们可以将复杂的内容简单化，每一层都专人做专事


应用层：处理引用层数据也就是报文
表示层：怎么把数据进行描述、数据如何进行描述，压缩
会话层：建立会话和管理会话
传输层：把应用层的数据装包，增加端口
网络层：网络层是寻址
数据链路层：主要关心的是两个设备连接起来连接数据
物理层：只关心如何传输数据 0 1，传输的是比特流

<br/>


## 七层协议真正都做了什么事情


- 报文 应用层 + 数据
- 数据段 传输层 + 数据 + 端口号
- 数据包 网络层 + 数据 +  端口号 + ip地址
- 数据帧 链路层 + 数据 + 端口 + ip + mac地址

> ip地址 + mac地址

IPV4 IP的第四个版本 最大值 42亿个

192.168.1.1  ip地址是固定的吗？ 不是固定的

> mac地址 原则上是唯一的，每个网卡都有一个mac地址 


### 物理层有哪些设备

- 光纤 同轴电缆 中继器 集线器 物理层就是关心怎么传输


### 数据链路层

-  交换机(局域网通信)，数据链路层交换的是mac地址

### 网络层设备
路由器 默认两个不同的网络 不能相互通信，想让两个不同的区域的设备来通信，要经历网关(路由器有wan口可以进行充当网关进行上网，没有wan口的就是交换机)

 ![avatar](./img/wangguan.png)

<br/>

### 网络的协议

- 协议就是约定和规范（在七层模型中只有3层以上的才能称之为协议）

应用层 HTTP DNS（域名解析协议）

传输层协议（TCP UDP）

网络层 IP协议 ARP协议（地址转换协议） 下层是为上层提供服务的

> ARP是有歧义的，核心价值是在于将IP地址转换成Mac地址，最终通信   靠的是Mac地址

> ARP会缓存列表 IP地址对应相应的物理地址

 ![avatar](./img/mac.png)

> DHCP协议，通过DHCP自动获取网络配置信息(动态主机配置协议)，我们无需配置IP,基于UDP

### DNS 因为用户很难记住IP地址

www.baidu.com.cn -> 三级域名

www.baidu.com -> 二级域名

baidu.com -> 一级域名

> DNS解析快是因为基于UDP（无连接）协议，不用三次握手四次挥手，而且基于缓存，DNS会缓存IP以及域名

 ![avatar](./img/dns.png)

 ## TCP和UDP
 
 <br/>

 > 两个协议都在传输层，我们经常说TCP是面向连接的而UDP是面向无连接的

 ### TCP

 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号，TCP是全双工服务

  ![avatar](./img/tcpconstructor.jpg)


+ 源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收

+ 32位序列号 TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值

+ 确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。

+ 首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。

+ 控制位 TCP的连接、传输和断开都受这六个控制位的指挥

+ PSH(push急迫位) 缓存区将满，立刻传输速度

+ RST(reset重置位) 连接断了重新连接

+ URG(urgent紧急位) 紧急信号

+ ACK(acknowledgement 确认)为1表示确认号

+ SYN(synchronous建立联机) 同步序号位 TCP建立连接时要将这个值设为1

+ FIN发送端完成位，提出断开连接的一方把FIN置为1表示要断开连接

+ 窗口值 说明本地可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以

+ 保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的

+ 窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。

+ 效验和: 用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据

+ 紧急指针：尽在 URG(urgent紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。

<br/>

### 三次握手

 ![avatar](./img/shake.png)

 为了方便描述我们将主动发起请求的172.16.17.94:65076 主机称为客户端，将返回数据的主机172.16.17.94:8080称为服务器，以下也是。

+ 第一次握手: 建立连接。客户端发送连接请求，发送SYN报文，将seq设置为0。然后，客户端进入SYN_SEND状态，等待服务器的确认。

+ 第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，发送ACK报文，将ack设置为1。同时，自己还要发送SYN请求信息，将seq为0。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态。

+ 第三次握手: 客户端收到服务器的ACK和SYN报文后，进行确认，然后将ack设置为1，seq设置为1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

<br/>

### 四次挥手

 ![avatar](./img/goodBye.png)

+ 第一次挥手：客户端向服务器发送一个FIN报文段，将设置seq为160和ack为112，;此时，客户端进入 FIN_WAIT_1状态,这表示客户端没有数据要发送服务器了，请求关闭连接;

+ 第二次挥手：服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，ack设置为1，seq设置为112;服务器进入了CLOSE_WAIT状态，客户端收到服务器返回的ACK报文后，进入FIN_WAIT_2状态;

+ 第三次挥手：服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送FIN报文；如果没有，那么服务器直接发送FIN报文给客户端。请求关闭连接，同时服务器进入LAST_ACK状态;

+ 第四次挥手：客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段，将seq设置为161，将ack设置为113，然后客户端进入TIME_WAIT状态;服务器收到客户端的ACK报文段以后，就关闭连接;此时，客户端等待2MSL后依然没有收到回复，则证明Server端已正常关闭，客户端也可以关闭连接了。

> 为了防止最终的ACK丢失，发送ACK后需要等待一段时间，因为如果丢失服务端需要重新发送FIN包，如果客户端已经closeed，那么服务端会将结果解析成错误，从而在高并发非长连接的场景下会有大量端口被占用，Http1.1就会有KeepLive解决这种问题。

<br/>

### 数据传输

 ![avatar](./img/datatransfer.jpg)


+ 客户端先向服务器发送数据，该数据报是长度为159的数据。

+ 服务器收到报文后, 也向客户端发送了一个数据进行确认（ACK），并且返回客户端要请求的数据，数据的长度为111，将seq设置为1，ack设置为160（1 + 159）。

+ 客户端收到服务器返回的数据后进行确认（ACK），将seq设置为160， ack设置为112（1 + 111）

### Q&A

1. 为什么需要三次握手? 

    因为TCP是双工协议

    客户端和服务端主动握手

    服务端应答后和客户端主动握手

    客户端应答

2. 为什么需要四次挥手? 

    双方数据发送完毕，都认为可以断开

3. 为什么需要等待? 

    A向B发的FIN可能丢失

4. 为什么握手是三次，但挥手却是四次?

     当Server端收到FIN报文时，很可能并不会立即关闭SOCKET

<br/>

## UDP

+ UDP是一个无连接、不保证可靠性的传输层协议，也就是说发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉 发送方是否收到了数据，它的可靠性由上层协议来保障

+ 首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用


### UDP的封装格式

 ![avatar](./img/15.udp.png)

 ![avatar](./img/udplength.png)

 ![avatar](./img/udpcheck.png)

 ### UDP的应用

+ QQ
+ 视频软件
+ TFTP 简单文件传输协议(短信)

node可以通过net模块模拟TCP，也可以通过dgram模拟UDP

```javaScript
    // UDP模块
    var dgram = require("dgram");
    var socket = dgram.createSocket("udp4");
    socket.on("message",(msg,rinfo)=>{
        conosle.log(msg.info);
        console.log(rinfo)
        socket.sned(msg,0,msg.length,rinfo.port,rinfo.address);
    })
    socket.bind(41234,"localhost")
```
<br/>

## 滑动窗口

> 属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量

我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。

这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。

如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。

 ![avatar](./img/640.png)

所以，这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

 ![avatar](./img/641.png)


 图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。

 > 窗口大小由哪一方决定？

 TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

> 发送方的滑动窗口

我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：

 ![avatar](./img/642.png)

+ #1 是已发送并收到 ACK确认的数据：1~31 字节
+ #2 是已发送但未收到 ACK确认的数据：32~45 字节
+ #3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节
+ #4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后
在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。

 ![avatar](./img/643.png)

 在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。

  ![avatar](./img/644.png)

> 程序是如何表示发送方的四个部分的呢？

TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

  ![avatar](./img/645.png)


+ SND.WND：表示发送窗口的大小（大小是由接收方指定的）；

+ SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。

+ SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。

+ 指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。


那么可用窗口大小的计算就可以是：

可用窗口大 = SND.WND -（SND.NXT - SND.UNA）


> 接收方的滑动窗口

接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：

+ #1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
+ #3 是未收到数据但可以接收的数据；
+ #4 未收到数据并不可以接收的数据；

  ![avatar](./img/646.png)


其中三个接收部分，使用两个指针进行划分:

+ RCV.WND：表示接收窗口的大小，它会通告给发送方。

+ RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。

+ 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。


> 接收窗口和发送窗口的大小是相等的吗？

并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

<br/>

### TCP拥塞处理

为什么要有拥塞控制呀，不是有流量控制了吗？

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了**拥塞控制**，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念。

什么是拥塞窗口？和发送窗口有什么关系呢？

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的。**

我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 cwnd 变化的规则：

+ 只要网络中没有出现拥塞，cwnd 就会增大；
+ 但网络中出现了拥塞，cwnd 就减少；

> 那么怎么知道当前网络是否出现了拥塞呢？

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了用拥塞。**

拥塞控制有哪些控制算法？

> 拥塞控制主要是四个算法：

+ 慢启动
+ 拥塞避免
+ 拥塞发生
+ 快速恢复
+ 慢启动

TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？

慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：

+ 连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。
+ 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个
+ 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个
+ 当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。

  ![avatar](./img/647.png)

<br/>

### **慢启动算法**

可以看出慢启动算法，发包的个数是指数性的增长。

> 那慢启动涨到什么时候是个头呢？

有一个叫慢启动门限  ssthresh （slow start threshold）状态变量。

+ 当 cwnd <  ssthresh 时，使用慢启动算法。
+ 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

<br/>

### **拥塞避免算法**

前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。

一般来说 ssthresh 的大小是 65535 字节。

那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

接上前面的慢启动的栗子，现假定 ssthresh 为 8：

+ 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。

![avatar](./img/648.png)

拥塞避免
所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

当触发了重传机制，也就进入了「拥塞发生算法」。

<br/>

### **拥塞发生**

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

+ 超时重传
+ 快速重传

这两种使用的拥塞发送算法是不同的，接下来分别来说说。

> 发生超时重传的拥塞发生算法

当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

+ ssthresh 设为 cwnd/2，
+ cwnd 重置为 1

![avatar](./img/649.png)

拥塞发送 —— 超时重传
接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。

就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。

> 发生快速重传的拥塞发生算法

还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

+ cwnd = cwnd/2 ，也就是设置为原来的一半;
+ ssthresh = cwnd;
进入快速恢复算法

<br/>

### **快速恢复**

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：

cwnd = cwnd/2 ，也就是设置为原来的一半;
ssthresh = cwnd;
然后，进入快速恢复算法如下：

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
重传丢失的数据包；
如果再收到重复的 ACK，那么 cwnd 增加 1；
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated  ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![avatar](./img/650.png)

快速重传和快速恢复
也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。

<br/>

## HTTP

+ HTTP1.1，增加了持久连接(connection:keep-live/close)，允许相应数据分块，增加了缓存管理和控制，增加了PUT,DELETE方法，HTTP1.1使用了管线话实现了并发请求，但是发的时候是并发，接受的时候还是要一个一个接收，(存在HTTP头阻塞问题，无法对请求头压缩，只能用纯文本)

    纯文本协议，安全问题(明文)，基于TCP传输层，半双工通信，请求问答模式，Http默认是无状态的（默认TCP不能在没有应答完成后后复用TCP通道继续发送消息，Http Over TCP

    tcp的规范
        
    + 请求行 相应行  主要目的是描述要做的事 服务端告诉客户端Ok
     
    + 请求头 响应头  描述我们传输的数据内容 自定义我们的header（Http中自己所做的规范）
    
    + 请求体 响应体 两者的数据

### keep-live


keep-Alive，(1.1 版本才支持)当使用此功能时，keep-alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求的时候，keep-alive 功能避免了建立或者重新创建连接



### 什么是管线化

在使用持久连接的情况下，某个连接消息的传递类似于

请求 1 -> 响应 1 -> 请求 2 -> 响应 2

管线化:某个连接上的消息变成了类似这样

请求 1 -> 请求 2 -> 请求 3 -> 响应 1 -> 响应 2 -> 响应 3

【注】

1. 那么持久连接和管线化的区别在于：

持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求 1 的响应收到之后，才会发送请求 2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。实现并行发送请求

2. 只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制

3. 初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。

4.HTTP1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器 Chrome 和 Firefox 默认并未开启管线化支持

5.管线化的不足之处：接收的响应要按照顺序返回，也是说，如果我中间某个请求没有处理完，接下来的 处理完的请求也会在等待阻塞中，这也会照成队头阻塞问题

### 2.首部字段结构

- HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。
- 另外，字段值对应单个 HTTP 首部字段可以有多个值。
- 当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。

| 首部字段名   | 冒号 | 字段值              |
| ------------ | ---- | ------------------- |
| Content-Type | ：   | text/html           |
| Keep-Alive   | ：   | timeout=30, max=120 |

### 3.首部字段类型

首部字段根据实际用途被分为以下 4 种类型：

| 类型         | 描述                                                                                                   |
| ------------ | ------------------------------------------------------------------------------------------------------ |
| 通用首部字段 | 请求报文和响应报文两方都会使用的首部                                                                   |
| 请求首部字段 | 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息 |
| 响应首部字段 | 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。   |
| 实体首部字段 | 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。               |

### 4.通用首部字段（HTTP/1.1）

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐挑首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

### 4.1 Cache-Control

通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。

### 4.1.1 可用的指令一览

可用的指令按请求和响应分类如下：

- 强缓存 协商缓存

- 强缓存 就是当客户端访问服务器后，服务器说，10S内别来找我了，去你家缓存找(在这10S内不会像服务器发送请求) Expires Cache-control:max-age 缓存最大时间

- 协商缓存的含义就是，当强制缓存失效后会再次像服务器发送请求，服务器需要对比客户端的缓存文件和服务端是否一致，如果一致则返回304状态，如果文件更新了，那么就采用返回新文件的方式 last-modified/if-modified-since。


**缓存请求指令**

| 指令              | 参数   | 说明                         |
| ----------------- | ------ | ---------------------------- |
| no-cache          | 无     | 强制向服务器再次验证         |
| no-store          | 无     | 不缓存请求或响应的任何内容   |
| max-age = [秒]    | 必需   | 响应的最大 Age 值            |
| max-stale( =[秒]) | 可省略 | 接收已过期的响应             |
| min-fresh = [秒]  | 必需   | 期望在指定时间内的响应仍有效 |
| no-transform      | 无     | 代理不可更改媒体类型         |
| only-if-cached    | 无     | 从缓存获取资源               |
| cache-extension   | -      | 新指令标记（token）          |

**缓存响应指令**

| 指令             | 参数   | 说明                                           |
| ---------------- | ------ | ---------------------------------------------- |
| public           | 无     | 可向任意方提供响应的缓存                       |
| private          | 可省略 | 仅向特定用户返回响应                           |
| no-cache         | 可省略 | 缓存前必须先确认其有效性                       |
| no-store         | 无     | 不缓存请求或响应的任何内容                     |
| no-transform     | 无     | 代理不可更改媒体类型                           |
| must-revalidate  | 无     | 可缓存但必须再向源服务器进行确认               |
| proxy-revalidate | 无     | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
| max-age = [秒]   | 必需   | 响应的最大 Age 值                              |
| s-maxage = [秒]  | 必需   | 公共缓存服务器响应的最大 Age 值                |
| cache-extension  | -      | 新指令标记（token）                            |

### 4.1.2 表示能否缓存的指令

**public 指令**
Cache-Control: public
当指定使用 public 指令时，则明确表明其他用户也可利用缓存。

**private 指令**
Cache-Control: private
当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。

**no-cache 指令**
Cache-Control: no-cache

- 使用 no-cache 指令是为了防止从缓存中返回过期的资源。
- 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。
- 如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。

Cache-Control: no-cache=Location
由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。

**no-store 指令**
Cache-Control: no-store
当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。
注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。

### 4.1.3 指定缓存期限和认证的指令

**s-maxage 指令**
Cache-Control: s-maxage=604800（单位：秒）

- s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。

- 另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。

**max-age 指令**
Cache-Control: max-age=604800（单位：秒）

- 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为 0，那么缓存服务器通常需要将请求转发给源服务器。

- 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。

- 应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。

**min-fresh 指令**
Cache-Control: min-fresh=60（单位：秒）

min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。

**max-stale 指令**
Cache-Control: max-stale=3600（单位：秒）

- 使用 max-stale 可指示缓存资源，即使过期也照常接收。

- 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。

**only-if-cached 指令**
Cache-Control: only-if-cached

- 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。

**must-revalidate 指令**
Cache-Control: must-revalidate

使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。

**proxy-revalidate 指令**
Cache-Control: proxy-revalidate
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。

**no-transform 指令**
Cache-Control: no-transform
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。

### 4.1.4 Cache-Control 扩展

Cache-Control: private, community="UCI"
通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。

### 4.2 Connection

Connection 首部字段具备以下两个作用：

**控制不再转发的首部字段**
Connection: Upgrade
在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即 Hop-by-hop 首部）。

**管理持久连接**
Connection: close
HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。

Connection: Keep-Alive
HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

### 4.3 Date

表明创建 HTTP 报文的日期和时间。
Date: Mon, 10 Jul 2017 15:50:06 GMT
HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。

### 4.4 Pragma

Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。
Pragma: no-cache

- 该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。

- 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：

```javaScript
    Cache-Control: no-cache
    Pragma: no-cache
```

### 4.5 Trailer

Trailer: Expires
首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。

### 4.6 Transfer-Encoding

Transfer-Encoding: chunked

- 规定了传输报文主体时采用的编码方式。
- HTTP/1.1 的传输编码方式仅对分块传输编码有效。

### 4.7 Upgrade

Upgrade: TSL/1.0
用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

### 4.8 Via

Via: 1.1 a1.sample.com(Squid/2.7)

- 为了追踪客户端和服务器端之间的请求和响应报文的传输路径。
- 报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。
- 首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。

### 4.9 Warning

该首部字段通常会告知用户一些与缓存相关的问题的警告。
Warning 首部字段的格式如下

Warning：[警告码][警告的主机:端口号] "[警告内容]"([日期时间])
最后的日期时间可省略。
HTTP/1.1 中定义了 7 种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。

| 警告码 | 警告内容                                       | 说明                                                             |
| ------ | ---------------------------------------------- | ---------------------------------------------------------------- |
| 110    | Response is stale(响应已过期)                  | 代理返回已过期的资源                                             |
| 111    | Revalidation failed(再验证失败)                | 代理再验证资源有效性时失败（服务器无法到达等原因）               |
| 112    | Disconnection operation(断开连接操作)          | 代理与互联网连接被故意切断                                       |
| 113    | Heuristic expiration(试探性过期)               | 响应的试用期超过 24 小时(有效缓存的设定时间大于 24 小时的情况下) |
| 199    | Miscellaneous warning(杂项警告)                | 任意的警告内容                                                   |
| 214    | Transformation applied(使用了转换)             | 代理对内容编码或媒体类型等执行了某些处理时                       |
| 299    | Miscellaneous persistent warning(持久杂项警告) | 任意的警告内容                                                   |

### 5.请求首部字段（HTTP/1.1）

| 首部字段名          | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | Web 认证信息                                  |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记（与 If-Macth 相反）              |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
| If-Unmodified-Since | 比较资源的更新时间(与 If-Modified-Since 相反) |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中 URI 的原始获取方                     |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP 客户端程序的信息                         |

### 5.1 Accept

Accept: text/html, application/xhtml+xml, application/xml; q=0.5

- Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

- 若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。

### 5.2 Accept-Charset

Accept-Charset: iso-8859-5, unicode-1-1; q=0.8
Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。

### 5.3 Accept-Encoding

Accept-Encoding: gzip, deflate
Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（\*）作为通配符，指定任意的编码格式。

### 5.4 Accept-Language

Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3
告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。

### 5.5 Authorization

Authorization: Basic ldfKDHKfkDdasSAEdasd==
告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。

### 5.6 Expect

Expect: 100-continue
告知服务器客户端期望出现的某种特定行为。

### 5.7 From

From: Deeson_Woo@163.com
告知服务器使用用户代理的电子邮件地址。

### 5.8 Host

Host: www.jianshu.com

- 告知服务器，请求的资源所处的互联网主机和端口号。
- **Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。**
- 若服务器未设定主机名，那直接发送一个空值即可 Host: 。

### 5.9 If-Match

形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

If-Match: "123456"

- 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。
- 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。
- 还可以使用星号（\*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。

### 5.10 If-Modified-Since

If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT

- 首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。
- 它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。

### 5.11 If-None-Match

If-None-Match: "123456"

首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。

### 5.12 If-Range

If-Range: "123456"

- 首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

- 下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。

### 5.13 If-Unmodified-Since

If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT

首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

### 5.14 Max-Forwards

Max-Forwards: 10

通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。

### 5.15 Proxy-Authorization

Proxy-Authorization: Basic dGlwOjkpNLAGfFY5

- 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。
- 这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。

### 5.16 Range

Range: bytes=5001-10000

- 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。
- 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。

### 5.17 Referer

Referer: http://www.sample.com/index.html

首部字段 Referer 会告知服务器请求的原始资源的 URI。

### 5.18 TE

TE: gzip, deflate; q=0.5

- 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

- 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers

### 5.19 User-Agent

User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101

- 首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。

- 由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。

### 6. 响应首部字段（HTTP/1.1）

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

### 6.1 Accept-Ranges

Accept-Ranges: bytes

- 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。

- 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。

### 6.2 Age

Age: 1200

- 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。

- 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。

### 6.3 ETag

ETag: "usagi-1234"

- 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。

- 另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。
- ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/"usagi-1234"。

### 6.4 Location

Location: http://www.sample.com/sample.html

- 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。

- 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。

* 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。

### 6.5 Proxy-Authenticate

Proxy-Authenticate: Basic realm="Usagidesign Auth"

- 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

- 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。

### 6.5 Proxy-Authenticate

Proxy-Authenticate: Basic realm="Usagidesign Auth"

- 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

- 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。

### 6.6 Retry-After

Retry-After: 180

- 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。

- 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。

### 6.7 Server

Server: Apache/2.2.6 (Unix) PHP/5.2.5

首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。

### 6.8 Vary

Vary: Accept-Language

- 首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。

- 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。

### 6.9 WWW-Authenticate

WWW-Authenticate: Basic realm="Usagidesign Auth"

首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。

### 7. 实体首部字段（HTTP/1.1）

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源可支持的 HTTP 方法       |
| Content-Encoding | 实体主体适用的编码方式       |
| Content-Language | 实体主体的自然语言           |
| Content-Length   | 实体主体的大小（单位：字节） |
| Content-Location | 替代对应资源的 URI           |
| Content-MD5      | 实体主体的报文摘要           |
| Content-Range    | 实体主体的位置范围           |
| Content-Type     | 实体主体的媒体类型           |
| Expires          | 实体主体过期的日期时间       |
| Last-Modified    | 资源的最后修改日期时间       |

### 7.1 Allow

Allow: GET, HEAD

- 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。

- 当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。

### 7.2 Content-Encoding

Content-Encoding: gzip

- 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。

- 主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。

### 7.3 Content-Language

Content-Language: zh-CN

首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。

### 7.4 Content-Length

Content-Length: 15000

首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。

### 7.5 Content-Location

Content-Location: http://www.sample.com/index.html

首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。

### 7.6 Content-MD5

Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==

首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。

### 7.7 Content-Range

Content-Range: bytes 5001-10000/10000

针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。

### 7.8 Content-Type

Content-Type: text/html; charset=UTF-8

首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。

### 7.9 Expires

Expires: Mon, 10 Jul 2017 15:50:06 GMT

- 首部字段 Expires 会将资源失效的日期告知客户端。
- 缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。
- 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。

### 7.10 Last-Modified

Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT

首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。

### 8. 为 Cookie 服务的首部字段

| 首部字段名 | 说明                             | 首部类型     |
| ---------- | -------------------------------- | ------------ |
| Set-Cookie | 开始状态管理所使用的 Cookie 信息 | 响应首部字段 |
| Cookie     | 服务器接收到的 Cookie 信息       | 请求首部字段 |

### 8.1 Set-Cookie

Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;

下面的表格列举了 Set-Cookie 的字段值。

| 属性         | 说明                                                                             |
| ------------ | -------------------------------------------------------------------------------- |
| NAME=VALUE   | 赋予 Cookie 的名称和其值（必需项）                                               |
| expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）                          |
| path=PATH    | 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） |
| domain=域名  | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）        |
| Secure       | 仅在 HTTPS 安全通信时才会发送 Cookie                                             |
| HttpOnly     | 加以限制，使 Cookie 不能被 JavaScript 脚本访问                                   |

### 8.1.1 expires 属性

- Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。
- 当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。
- 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。


### 8.1.2 path 属性

Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。

### 8.1.3 domain 属性

- 通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie

* 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。

### 8.1.4 secure 属性

Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。

### 8.1.5 HttpOnly 属性

- Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。

- 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。

### 8.2 Cookie

Cookie: status=enable
首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。

### 9. 其他首部字段

HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。
以下是最为常用的首部字段。

### 9.1 X-Frame-Options

X-Frame-Options: DENY
首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：

- DENY：拒绝

- SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 http://sample.com/sample.html 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com等其他域名的页面就不行了）

### 9.2 X-XSS-Protection

X-XSS-Protection: 1
首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:

- 0 ：将 XSS 过滤设置成无效状态
- 1 ：将 XSS 过滤设置成有效状态

### 9.3 DNT

DNT: 1
首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：

- 0 ：同意被追踪
- 1 ：拒绝被追踪

### 9.4 P3P

P3P: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND
首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。
要进行 P3P 的设定，需按以下操作步骤进行：

- 步骤 1：创建 P3P 隐私
- 步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml
- 步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中

### 七、HTTP 响应状态码（重点分析）

### 1. 状态码概述

- HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。
- HTTP 状态码如 200 OK ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。
- 不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。

### 2. 状态码类别

| 状态码 | 类别                           | 原因短语                   |
| ------ | ------------------------------ | -------------------------- |
| 1xx    | Informational(信息性状态码)    | 接收的请求正在处理         |
| 2xx    | Success(成功状态码)            | 请求正常处理完毕           |
| 3xx    | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4xx    | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5xx    | Server Error(服务器错误状态码) | 服务器处理请求出错         |

我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。

### 3. 常用状态码解析

HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。

### 3.1 200 OK

表示从客户端发来的请求在服务器端被正常处理了。

### 3.2 204 No Content

- 代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。
- 一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。

### 3.3 206 Partial Content

表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。

### 3.4 301 Moved Permanently

永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

### 3.5 302 Found

- 临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

- 和 301 Moved Permanently 状态码相似，但 302 Found 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。

### 3.6 303 See Other

- 表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

- 303 See Other 和 302 Found 状态码有着相同的功能，但 303 See Other 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 Found 状态码有区别。

### 3.7 304 Not Modified

- 表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。

- 304 Not Modified状态码返回时，不包含任何响应的主体部分。
- 304 Not Modified虽然被划分到 3xx 类别中，但和重定向没有关系。

### 3.8 307 Temporary Redirect

临时重定向。该状态码与 302 Found 有着相同的含义。

### 3.9 400 Bad Request

- 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。
- 另外，浏览器会像 200 OK 一样对待该状态码。

### 3.10 401 Unauthorized

- 表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。
- 另外，若之前已进行过 1 次请求，则表示用户认证失败。
- 返回含有 401 Unauthorized 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。

### 3.11 403 Forbidden

表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。

### 3.12 404 Not Found

表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。

### 3.13 500 Internal Server Error

表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。

### 3.14 503 Service Unavailable

表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。

## 八、HTTP 报文实体

### 1.Http 报文实体概述

![avatar](./img/13.jpg)

大家请仔细看看上面示例中，各个组成部分对应的内容。
接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。

- 报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。

- 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）
  我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。

**通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。**

### 2.内容编码

- HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。

- 这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。

内容编码类型：

| 编码方式 | 类别描述                                                                       |
| -------- | ------------------------------------------------------------------------------ |
| gzip     | 表明实体采用 GNU zip 编码                                                      |
| compress | 表明实体采用 Unix 的文件压缩程序                                               |
| deflate  | 表明实体采用 zlib 的格式压缩的                                                 |
| identity | 表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式 |

<br/>

### HTTP2

+ 使用HPACK算法压缩头部，减少数据传输量，允许服务器主动向客户端推送数据，二进制可发起多个请求，使用时需要对请求加密通信（多路复用 1条TCP连接来通信数据，多条请求拆分为帧，放在一条TCP连接里）

+ http2.0实现了多路复用

+ 在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

+ 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）

+ 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。

+ HTTP/2 的多路复用就是为了解决上述的两个性能问题。

+ 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

+ 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

+ 多路复用就是将多个请求复用同一个TCP链接中，将TCP分成若干个流，每个流中可以传输若干个消息，每个消息由若干个最小二进制帧组成。相当于我一个很大的请求，拆分成很多个很小的帧，这样处理帧还是很快的，就不会造成堵塞了。


### HTTP3，基于UDP的QUIC协议


### HTTPS

**为什么需要加密？**

因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最容易理解的就是对称加密 。

什么是对称加密？

简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。


![avatar](./img/https1.webp)

**用对称加密可行吗？**

**如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。**

然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。

换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行了！这么做显然不现实。
怎么办？所以我们就需要非对称加密 。

**什么是非对称加密？**

简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

![avatar](./img/https2.webp)

**用非对称加密可行吗？**

鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开公钥加密的数据。

然而反过来由服务器到浏览器的这条路怎么保障安全？如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据的安全性（其实仍有漏洞，下文会说），那利用这点你能想到什么解决方案吗

**改良的非对称加密方案，似乎可以？**

我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性，那用两组公钥私钥，是否就能保证双向传输都安全了？请看下面的过程：

- 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。

- 浏览器把公钥B明文传输给服务器。

- 服务器把公钥A明文给传输浏览器。

- 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。

- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。

的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？很重要的原因是非对称加密算法非常耗时，而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的漏洞？


**非对称加密+对称加密？**

既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。
请看一下这个过程：

- 某网站拥有用于非对称加密的公钥A、私钥A’。

- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。

- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。

- 服务器拿到后用私钥A’解密得到密钥X。

- 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

- 完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。

**中间人攻击**

![avatar](./img/https3.webp)

如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：

- 某网站有用于非对称加密的公钥A、私钥A’。

- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。

- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。

- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。

- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。

- 服务器拿到后用私钥A’解密得到密钥X。

这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋、蛋生鸡的问题了。解法是什么？

**如何证明浏览器收到的公钥一定是该网站的公钥？**

其实所有证明的源头都是一条或多条不证自明的“公理”（可以回想一下数学上公理），由它推导出一切。比如现实生活中，若想证明某身份证号一定是小明的，可以看他身份证，而身份证是由政府作证的，这里的“公理”就是“政府机构可信”，这也是社会正常运作的前提。

那能不能类似地有个机构充当互联网世界的“公理”呢？让它作为一切证明的源头，给网站颁发一个“身份证”？

它就是CA机构，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是数字证书。

**数字证书**

网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“证书本身的传输过程中，如何防止被篡改”？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！

**如何放防止数字证书被篡改？**

我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫数字签名：

**数字签名**

这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：

 ![avatar](./img/https4.webp)

**数字签名的制作过程：**

- CA机构拥有非对称加密的私钥和公钥。

- CA机构对证书明文数据T进行hash。

- 对hash后的值用私钥加密，得到数字签名S。

- 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。

- 那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）

**浏览器验证过程：**

- 拿到证书，得到明文T，签名S。

- 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。

- 用证书里指明的hash算法对明文T进行hash得到T’。

- 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

- 为何么这样可以保证证书可信呢？我们来仔细想一下。

**中间人有可能把证书掉包吗？**

假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？

其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了

**为什么制作数字签名时需要hash一次？**

我初识HTTPS的时候就有这个疑问，因为似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。

最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。

**怎么证明CA机构的公钥是可信的？**

你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？

让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。

实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。

**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？**

这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？

服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！


**HTTPS完整建立连接过程,如下图**

首先建立tcp握手连接

进行ssl协议的握手密钥交换(Handshake protocal)

然后通过共同约定的密钥开始通信

 ![avatar](./img/https_protocal.png)





